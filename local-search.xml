<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Linux 计算过对比及优化过程</title>
    <link href="/2025/12/27/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/Linux%20%E8%AE%A1%E7%AE%97%E8%BF%87%E5%AF%B9%E6%AF%94%E5%8F%8A%E4%BC%98%E5%8C%96%E8%BF%87%E7%A8%8B/"/>
    <url>/2025/12/27/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/Linux%20%E8%AE%A1%E7%AE%97%E8%BF%87%E5%AF%B9%E6%AF%94%E5%8F%8A%E4%BC%98%E5%8C%96%E8%BF%87%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="test-foo：A-A-T-性能对比与优化分析（Eigen-vs-多层-for）"><a href="#test-foo：A-A-T-性能对比与优化分析（Eigen-vs-多层-for）" class="headerlink" title="test_foo：A * A^T 性能对比与优化分析（Eigen vs 多层 for）"></a>test_foo：A * A^T 性能对比与优化分析（Eigen vs 多层 for）</h1><h2 id="代码功能分析"><a href="#代码功能分析" class="headerlink" title="代码功能分析"></a>代码功能分析</h2><h3 id="文件功能概述"><a href="#文件功能概述" class="headerlink" title="文件功能概述"></a>文件功能概述</h3><p><code>test_foo.cc</code> 是一个性能基准测试程序，用于对比 <strong>Eigen 库</strong> 和 <strong>手动多层 for 循环</strong> 两种方法在计算对称矩阵乘法 <code>C = A * A^T</code> 时的性能差异。</p><p><strong>测试参数</strong>：</p><ul><li>输入矩阵：<code>A</code>，类型 <code>uint16_t</code>（实现中转为 <code>uint64_t</code> 防溢出）</li><li>维度：<code>A</code> 为 1080×1920</li><li>计算：<code>C = A * A^T</code></li><li>输出矩阵：<code>C</code>，维度 1080×1080（Gram 矩阵，天然对称）</li><li>计算量级：约 $1080\times1080\times1920 \approx 2.24\times 10^9$ 次乘加</li></ul><h3 id="核心功能模块"><a href="#核心功能模块" class="headerlink" title="核心功能模块"></a>核心功能模块</h3><h4 id="1-数据生成-make-fixed-u16-1080x1920"><a href="#1-数据生成-make-fixed-u16-1080x1920" class="headerlink" title="1. 数据生成 (make_fixed_u16_1080x1920)"></a>1. 数据生成 (<code>make_fixed_u16_1080x1920</code>)</h4><ul><li><strong>功能</strong>：生成固定的 1080×1920 的 <code>uint16_t</code> 矩阵数据</li><li><strong>特点</strong>：使用确定性算法（<code>i*131 + j*17 + 7</code>），确保结果可复现</li><li><strong>用途</strong>：避免全 0&#x2F;全 1 等特殊模式，提供真实的测试数据</li></ul><h4 id="2-Eigen-实现-eigen-rankupdate-selfadjoint-full"><a href="#2-Eigen-实现-eigen-rankupdate-selfadjoint-full" class="headerlink" title="2. Eigen 实现 (eigen_rankupdate_selfadjoint_full)"></a>2. Eigen 实现 (<code>eigen_rankupdate_selfadjoint_full</code>)</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs 112:124:tests/test_foo.cc">void eigen_rankupdate_selfadjoint_full(<br>    const Eigen::Matrix&lt;U64, Eigen::Dynamic, Eigen::Dynamic, Eigen::RowMajor&gt;&amp; a64,<br>    Eigen::Matrix&lt;U64, Eigen::Dynamic, Eigen::Dynamic, Eigen::RowMajor&gt;&amp; c_full) &#123;<br>    // 只更新一个三角，再镜像得到完整对称矩阵。<br>    c_full.setZero();<br>    c_full.template selfadjointView&lt;Eigen::Lower&gt;().rankUpdate(a64);<br><br>    for (int i = 0; i &lt; kH; ++i) &#123;<br>        for (int j = i + 1; j &lt; kH; ++j) &#123;<br>            c_full(i, j) = c_full(j, i);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><strong>优化策略</strong>：<ul><li>使用 <code>selfadjointView&lt;Eigen::Lower&gt;().rankUpdate()</code> 只计算下三角</li><li>利用 Eigen 的对称矩阵优化路径（类似 BLAS SYRK）</li><li>手动镜像上三角部分</li></ul></li></ul><h4 id="3-多层-for-循环实现-matmul-self-loop-blocked-half"><a href="#3-多层-for-循环实现-matmul-self-loop-blocked-half" class="headerlink" title="3. 多层 for 循环实现 (matmul_self_loop_blocked_half)"></a>3. 多层 for 循环实现 (<code>matmul_self_loop_blocked_half</code>)</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs 72:110:tests/test_foo.cc">Eigen::Matrix&lt;U64, Eigen::Dynamic, Eigen::Dynamic, Eigen::RowMajor&gt; matmul_self_loop_blocked_half(<br>    const Eigen::Matrix&lt;U64, Eigen::Dynamic, Eigen::Dynamic, Eigen::RowMajor&gt;&amp; a64,<br>    bool enable_openmp) &#123;<br>    Eigen::Matrix&lt;U64, Eigen::Dynamic, Eigen::Dynamic, Eigen::RowMajor&gt; c(kH, kH);<br>    c.setZero();<br><br>    constexpr int kJBlock = 16;<br><br>#ifdef _OPENMP<br>#pragma omp parallel for schedule(static) if(enable_openmp)<br>#else<br>    (void)enable_openmp;<br>#endif<br>    for (int i = 0; i &lt; kH; ++i) &#123;<br>        const U64* row_i = a64.data() + static_cast&lt;std::size_t&gt;(i) * static_cast&lt;std::size_t&gt;(kW);<br><br>        // 只计算上三角（j &gt;= i），再镜像到下三角。<br>        for (int jb = i; jb &lt; kH; jb += kJBlock) &#123;<br>            const int j_end = (jb + kJBlock &lt; kH) ? (jb + kJBlock) : kH;<br>            U64 sums[kJBlock] = &#123;0&#125;;<br><br>            for (int k = 0; k &lt; kW; ++k) &#123;<br>                const U64 a_ik = row_i[k];<br>                for (int j = jb; j &lt; j_end; ++j) &#123;<br>                    const U64* row_j = a64.data() + static_cast&lt;std::size_t&gt;(j) * static_cast&lt;std::size_t&gt;(kW);<br>                    sums[j - jb] += a_ik * row_j[k];<br>                &#125;<br>            &#125;<br><br>            for (int j = jb; j &lt; j_end; ++j) &#123;<br>                const U64 v = sums[j - jb];<br>                c(i, j) = v;<br>                c(j, i) = v;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    return c;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><strong>优化策略</strong>：<ul><li><strong>对称性利用</strong>：只计算上三角（<code>j &gt;= i</code>），然后镜像到下三角</li><li><strong>分块处理</strong>：<code>j</code> 维度按块大小 16 分块，提高缓存局部性</li><li><strong>OpenMP 并行</strong>：外层 <code>i</code> 循环可并行化，支持环境变量控制</li><li><strong>数据复用</strong>：内层 <code>k</code> 循环中，<code>a_ik</code> 被复用计算多个 <code>j</code></li></ul></li></ul><h4 id="4-性能测量-time-average-ms"><a href="#4-性能测量-time-average-ms" class="headerlink" title="4. 性能测量 (time_average_ms)"></a>4. 性能测量 (<code>time_average_ms</code>)</h4><ul><li><strong>方法</strong>：先预热 10 次，再执行 50 次测量取平均</li><li><strong>目的</strong>：消除冷启动、缓存预热等影响，获得稳定性能数据</li></ul><h4 id="5-结果验证-hash-matrix-u64"><a href="#5-结果验证-hash-matrix-u64" class="headerlink" title="5. 结果验证 (hash_matrix_u64)"></a>5. 结果验证 (<code>hash_matrix_u64</code>)</h4><ul><li><strong>方法</strong>：使用 FNV-1a 64 位哈希算法计算矩阵哈希值</li><li><strong>优势</strong>：避免逐元素比较，快速验证两种实现结果一致性</li></ul><h3 id="测试流程"><a href="#测试流程" class="headerlink" title="测试流程"></a>测试流程</h3><ol><li>生成固定的 1080×1920 <code>uint16_t</code> 矩阵</li><li>转换为 <code>uint64_t</code> 矩阵（防止溢出）</li><li>分别用 Eigen 和 Loop 方法计算 <code>C = A * A^T</code></li><li>比较两种方法的执行时间和结果一致性</li></ol><h2 id="优化实现与性能结果"><a href="#优化实现与性能结果" class="headerlink" title="优化实现与性能结果"></a>优化实现与性能结果</h2><h3 id="已实现的优化"><a href="#已实现的优化" class="headerlink" title="已实现的优化"></a>已实现的优化</h3><h4 id="Eigen-版本优化"><a href="#Eigen-版本优化" class="headerlink" title="Eigen 版本优化"></a>Eigen 版本优化</h4><ul><li><strong>对称性利用</strong>：使用 <code>selfadjointView().rankUpdate()</code> 只计算下三角，再镜像补全</li><li><strong>统计方式</strong>：warm up 10 次，再循环 50 次计时取平均</li></ul><h4 id="Loop-版本优化"><a href="#Loop-版本优化" class="headerlink" title="Loop 版本优化"></a>Loop 版本优化</h4><ul><li><strong>对称性利用</strong>：只算半边（<code>j&gt;=i</code>），再镜像到下三角</li><li><strong>分块优化</strong>：块大小 16，提高缓存局部性</li><li><strong>OpenMP 并行</strong>：外层 <code>i</code> 循环并行化（可通过环境变量 <code>NNDEPLOY_BENCH_DISABLE_OMP=1</code> 关闭）</li></ul><h3 id="最新实测结果（含-CUDA-OpenCL）"><a href="#最新实测结果（含-CUDA-OpenCL）" class="headerlink" title="最新实测结果（含 CUDA&#x2F;OpenCL）"></a>最新实测结果（含 CUDA&#x2F;OpenCL）</h3><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">u16 固定矩阵维度: <span class="hljs-number">1080</span>x1920<br>计算: C = A * A^T (结果维度 <span class="hljs-number">1080</span>x1080)<br><br>Eigen 用时: <span class="hljs-number">281.72</span> <span class="hljs-keyword">ms</span><br><span class="hljs-title">Loop</span>  用时: <span class="hljs-number">507.922</span> <span class="hljs-keyword">ms</span><br><span class="hljs-title">CUDA</span>  用时: <span class="hljs-number">43.6833</span> <span class="hljs-keyword">ms</span><br><span class="hljs-title">OpenCL</span> 用时: <span class="hljs-number">216.147</span> <span class="hljs-keyword">ms</span><br><br><span class="hljs-title">CUDA</span>  hash: <span class="hljs-number">6808166764559248003</span><br>OpenCL hash: <span class="hljs-number">6808166764559248003</span><br>Eigen hash: <span class="hljs-number">6808166764559248003</span><br>Loop  hash: <span class="hljs-number">6808166764559248003</span><br>结果一致: YES<br></code></pre></td></tr></table></figure><h4 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h4><ul><li><strong>所有实现（Eigen&#x2F;Loop&#x2F;CUDA&#x2F;OpenCL）结果完全一致，均通过哈希校验。</strong></li><li><strong>计时均为端到端耗时</strong>，即包括主机与设备间数据搬运、内核执行、结果回传等全部阶段。</li><li><strong>CUDA 性能最优</strong>，远超 OpenCL，主要因 NVIDIA 平台对 CUDA 优化更深，OpenCL 驱动和内核优化有限。</li><li><strong>OpenCL 性能优于 CPU，但明显慢于 CUDA</strong>，为 GPU 通用接口的典型表现。</li></ul><h3 id="优化效果"><a href="#优化效果" class="headerlink" title="优化效果"></a>优化效果</h3><ul><li><strong>Eigen 方案</strong>：性能提升显著（原约 564ms → 280ms，提升约 2 倍），充分利用了对称性和底层库加速</li><li><strong>Loop 方案</strong>：性能明显提升（原约 1190ms → 505ms，提升约 2.35 倍），分块和只算半边有效减少了计算量和缓存压力</li><li><strong>正确性</strong>：两者结果完全一致（哈希验证），说明优化未影响正确性</li></ul><blockquote><p><strong>说明</strong>：不同机器&#x2F;编译参数&#x2F;线程数&#x2F;CPU 调度会导致数值波动，上述数据仅供参考。</p></blockquote><h2 id="优化可行性分析"><a href="#优化可行性分析" class="headerlink" title="优化可行性分析"></a>优化可行性分析</h2><h3 id="当前实现的优化评估"><a href="#当前实现的优化评估" class="headerlink" title="当前实现的优化评估"></a>当前实现的优化评估</h3><h4 id="✅-Eigen-版本优化（已实现且可行）"><a href="#✅-Eigen-版本优化（已实现且可行）" class="headerlink" title="✅ Eigen 版本优化（已实现且可行）"></a>✅ Eigen 版本优化（已实现且可行）</h4><p><strong>实现方式</strong>：</p><ul><li>使用 <code>selfadjointView&lt;Eigen::Lower&gt;().rankUpdate(a64)</code> 计算下三角</li><li>手动镜像到上三角</li></ul><p><strong>可行性评估</strong>：</p><ul><li>✅ <strong>完全可行</strong>：Eigen 的 <code>rankUpdate</code> 专门为对称矩阵优化，计算量约为完整矩阵乘法的一半</li><li>✅ <strong>正确性保证</strong>：利用数学对称性（<code>C = A * A^T</code> 天然对称），镜像操作不会引入误差</li><li>✅ <strong>性能收益</strong>：实测从约 564ms 降至 280ms，提升约 2 倍</li></ul><p><strong>潜在改进空间</strong>：</p><ul><li>可考虑使用 <code>selfadjointView&lt;Eigen::Upper&gt;()</code> 配合不同布局，但收益有限</li><li>如果链接高性能 BLAS（如 MKL&#x2F;OpenBLAS），<code>rankUpdate</code> 会自动使用优化的 SYRK 内核</li></ul><h4 id="✅-Loop-版本优化（已实现且可行）"><a href="#✅-Loop-版本优化（已实现且可行）" class="headerlink" title="✅ Loop 版本优化（已实现且可行）"></a>✅ Loop 版本优化（已实现且可行）</h4><p><strong>实现方式</strong>：</p><ol><li><strong>对称性利用</strong>：只计算 <code>j &gt;= i</code> 的上三角部分</li><li><strong>分块优化</strong>：<code>j</code> 维度按块大小 16 分块处理</li><li><strong>OpenMP 并行</strong>：外层 <code>i</code> 循环并行化</li></ol><p><strong>可行性评估</strong>：</p><ol><li><p><strong>对称性优化</strong> ✅</p><ul><li><strong>数学正确性</strong>：<code>C(i,j) = C(j,i)</code> 对于 <code>A * A^T</code> 恒成立</li><li><strong>计算量减少</strong>：理论上减少约 50% 的乘加运算</li><li><strong>实现简单</strong>：只需改变循环边界和添加镜像操作</li><li><strong>实测效果</strong>：从约 1190ms 降至 505ms，提升约 2.35 倍</li></ul></li><li><p><strong>分块优化</strong> ✅</p><ul><li><strong>缓存友好性</strong>：块大小 16 使得 <code>sums[kJBlock]</code> 数组（128 字节）能很好地适配 L1 缓存</li><li><strong>数据复用</strong>：内层 <code>k</code> 循环中，<code>a_ik</code> 被复用计算多个 <code>j</code>，提高计算密度</li><li><strong>指令级并行</strong>：多个 <code>sums[j]</code> 的累加可以并行执行</li><li><strong>可调参数</strong>：块大小可根据目标 CPU 缓存特性调整（8&#x2F;16&#x2F;32&#x2F;64）</li></ul></li><li><p><strong>OpenMP 并行</strong> ✅</p><ul><li><strong>数据独立性</strong>：外层 <code>i</code> 循环之间无数据依赖，天然可并行</li><li><strong>负载均衡</strong>：<code>schedule(static)</code> 适合计算量均匀的场景</li><li><strong>环境控制</strong>：通过 <code>NNDEPLOY_BENCH_DISABLE_OMP</code> 环境变量可灵活开关</li><li><strong>注意事项</strong>：需确保与 Eigen 版本使用相同的线程策略进行公平对比</li></ul></li></ol><h3 id="进一步优化方向评估"><a href="#进一步优化方向评估" class="headerlink" title="进一步优化方向评估"></a>进一步优化方向评估</h3><h4 id="1-更大块分块-⚠️-需测试"><a href="#1-更大块分块-⚠️-需测试" class="headerlink" title="1. 更大块分块 ⚠️ 需测试"></a>1. 更大块分块 ⚠️ 需测试</h4><ul><li><strong>可行性</strong>：块大小可调整为 32&#x2F;64&#x2F;128</li><li><strong>风险</strong>：块过大可能导致 L1 缓存溢出，反而降低性能</li><li><strong>建议</strong>：通过基准测试找到最优块大小（通常与 CPU 缓存行大小相关）</li></ul><h4 id="2-K-维度分块-✅-可行"><a href="#2-K-维度分块-✅-可行" class="headerlink" title="2. K 维度分块 ✅ 可行"></a>2. K 维度分块 ✅ 可行</h4><ul><li><strong>思路</strong>：对 <code>k</code> 维度也进行分块，进一步提高缓存局部性</li><li><strong>实现</strong>：在现有 <code>j</code> 分块基础上，增加 <code>k</code> 维度的分块循环</li><li><strong>收益</strong>：对于大矩阵（kW&#x3D;1920），可能显著减少内存访问</li><li><strong>复杂度</strong>：需要三层分块嵌套，代码复杂度增加</li></ul><h4 id="3-手动向量化（SIMD）✅-可行但复杂"><a href="#3-手动向量化（SIMD）✅-可行但复杂" class="headerlink" title="3. 手动向量化（SIMD）✅ 可行但复杂"></a>3. 手动向量化（SIMD）✅ 可行但复杂</h4><ul><li><strong>可行性</strong>：使用 AVX2&#x2F;AVX-512 指令集手动优化内层循环</li><li><strong>收益</strong>：理论上可提升 4-8 倍（取决于 SIMD 宽度）</li><li><strong>成本</strong>：需要平台特定代码，维护成本高</li><li><strong>替代方案</strong>：依赖编译器自动向量化（<code>-march=native -O3</code>）</li></ul><h4 id="4-更高级的并行策略-⚠️-需权衡"><a href="#4-更高级的并行策略-⚠️-需权衡" class="headerlink" title="4. 更高级的并行策略 ⚠️ 需权衡"></a>4. 更高级的并行策略 ⚠️ 需权衡</h4><ul><li><strong>动态调度</strong>：<code>schedule(dynamic)</code> 可能在某些场景下更好</li><li><strong>嵌套并行</strong>：对 <code>j</code> 块也并行化，但可能引入线程开销</li><li><strong>NUMA 感知</strong>：多插槽系统需要考虑内存亲和性</li></ul><h3 id="优化建议总结"><a href="#优化建议总结" class="headerlink" title="优化建议总结"></a>优化建议总结</h3><table><thead><tr><th>优化方向</th><th>可行性</th><th>实现难度</th><th>预期收益</th><th>推荐优先级</th></tr></thead><tbody><tr><td>对称性利用（已实现）</td><td>✅ 高</td><td>低</td><td>高（~2x）</td><td>⭐⭐⭐⭐⭐</td></tr><tr><td>分块优化（已实现）</td><td>✅ 高</td><td>中</td><td>中（~1.2-1.5x）</td><td>⭐⭐⭐⭐</td></tr><tr><td>OpenMP 并行（已实现）</td><td>✅ 高</td><td>低</td><td>高（多核场景）</td><td>⭐⭐⭐⭐</td></tr><tr><td>K 维度分块</td><td>✅ 中</td><td>中</td><td>中（~1.2-1.3x）</td><td>⭐⭐⭐</td></tr><tr><td>更大块分块</td><td>⚠️ 需测试</td><td>低</td><td>低-中</td><td>⭐⭐</td></tr><tr><td>手动 SIMD</td><td>✅ 高</td><td>高</td><td>高（~2-4x）</td><td>⭐⭐</td></tr><tr><td>链接高性能 BLAS</td><td>✅ 高</td><td>低</td><td>很高（~2-5x）</td><td>⭐⭐⭐⭐⭐</td></tr></tbody></table><h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><p><strong>当前实现的优化完全可行且有效</strong>：</p><ul><li>✅ 数学正确性：对称性利用基于严格的数学性质</li><li>✅ 性能提升显著：Eigen 版本提升约 2 倍，Loop 版本提升约 2.35 倍</li><li>✅ 结果一致性：两种方法结果完全一致（哈希验证）</li><li>✅ 代码质量：实现清晰，可维护性好</li></ul><p><strong>推荐下一步</strong>：</p><ol><li><strong>短期</strong>：尝试调整块大小（8&#x2F;16&#x2F;32&#x2F;64），找到最优值</li><li><strong>中期</strong>：实现 K 维度分块，进一步提升缓存效率</li><li><strong>长期</strong>：如果允许外部依赖，链接 OpenBLAS&#x2F;MKL 可获得最大性能提升</li></ol><h2 id="通用优化建议"><a href="#通用优化建议" class="headerlink" title="通用优化建议"></a>通用优化建议</h2><h3 id="编译与构建选项"><a href="#编译与构建选项" class="headerlink" title="编译与构建选项"></a>编译与构建选项</h3><p>优先确保 <strong>Release + 高优化</strong>：</p><ul><li><code>-O3 -DNDEBUG</code></li><li><code>-march=native</code>（在目标机器本地编译时）</li></ul><p>说明：本基准主要是整数乘加，<code>-ffast-math</code> 对浮点更相关，这里不属于第一优先级。</p><h3 id="线程-核绑定与频率稳定"><a href="#线程-核绑定与频率稳定" class="headerlink" title="线程&#x2F;核绑定与频率稳定"></a>线程&#x2F;核绑定与频率稳定</h3><ul><li>想要 <strong>可复现</strong> 的对比：建议两边统一为单线程，并绑定固定 CPU 核</li><li>想要 <strong>最快</strong>：则允许 Eigen&#x2F;BLAS&#x2F;for-loop 并行吃满 CPU</li></ul><p>常用方法：</p><ul><li>绑核：<code>taskset -c 0 ./UnitTestFoo</code></li><li>统一 OpenMP 线程：<code>OMP_NUM_THREADS=1</code></li><li>若使用 OpenBLAS：<code>OPENBLAS_NUM_THREADS=1</code></li></ul><blockquote><p>建议在对比时明确写清：是否绑核、线程数、是否开启睿频&#x2F;性能模式。</p></blockquote><h3 id="测量方法"><a href="#测量方法" class="headerlink" title="测量方法"></a>测量方法</h3><ul><li>预热：首次运行常包含冷缓存、缺页、动态库初始化等开销</li><li>多次测量：建议跑 3~10 次，取最小值或中位数</li></ul><h2 id="性能瓶颈分析"><a href="#性能瓶颈分析" class="headerlink" title="性能瓶颈分析"></a>性能瓶颈分析</h2><p>该计算的性能瓶颈主要来自：</p><ol><li><strong>计算量巨大</strong>：约 $2.24\times 10^9$ 次乘加运算</li><li><strong>内存带宽</strong>：需要频繁访问大量矩阵数据</li><li><strong>缓存效率</strong>：矩阵尺寸较大，容易产生缓存 miss</li><li><strong>并行度</strong>：是否能充分利用 SIMD（向量化）与多核</li></ol><p>因此优化方向应聚焦于：</p><ul><li>利用对称性减少一半计算</li><li>提高缓存访问友好性（分块、数据复用）</li><li>充分利用 SIMD 向量化和多核并行</li></ul>]]></content>
    
    
    <categories>
      
      <category>性能优化</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>CPU性能分析与优化</title>
    <link href="/2024/05/06/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/CPU%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E4%B8%8E%E4%BC%98%E5%8C%96/"/>
    <url>/2024/05/06/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/CPU%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E4%B8%8E%E4%BC%98%E5%8C%96/</url>
    
    <content type="html"><![CDATA[<h2 id="现代CPU性能分析"><a href="#现代CPU性能分析" class="headerlink" title="现代CPU性能分析"></a>现代CPU性能分析</h2><h3 id="性能测量"><a href="#性能测量" class="headerlink" title="性能测量"></a>性能测量</h3><p>理解应用程序性能的第一步是学会对它进行测量，基准测试每次运行的结果都不尽相同，因为在性能测量中存在误差，性能分析通常需要通过统计方法进行处理。<br>设计性能测试和配置测试环境都是性能评估工作的重要组成部分。</p><h4 id="现代系统中的噪声"><a href="#现代系统中的噪声" class="headerlink" title="现代系统中的噪声"></a>现代系统中的噪声</h4><p>以动态频率调节（DFS）为例，它是一个在短时间内提升CPU频率让其运行速度明显加快的特性。但是，CPU不能长时间处于“超频”状态，稍后它会降低到基本值。DFS很大程度上由CPU核的温度决定，因此很难预测其对实验结果的影响。</p><p>经验：即使运行任务管理工具-例如TOP指令，也会影响测量结果，因为某些CPU核会被激活并分配给该工具的进程，这可能会影响运                                                                                        </p><h4 id="手动性能测试"><a href="#手动性能测试" class="headerlink" title="手动性能测试"></a>手动性能测试</h4><p>正常提交变更代码时，我们需要确保性能没有退化，一般通过以下三步完成：<br>1、测量基线性能；<br>2、测量修改后程序的性能；<br>3、对两者进行比较；</p><h4 id="软件计时器和硬件计时器"><a href="#软件计时器和硬件计时器" class="headerlink" title="软件计时器和硬件计时器"></a>软件计时器和硬件计时器</h4><p>1、系统级高分辨率计时器：系统计时器，通过统计自某任意时间起开始流逝的滴答数而实现。在Linux操作系统下，可通过clock_gettime系统调用访问系统计时器；在C++语言中，标准的做法是使用std::chrono访问系统计时器。<br>2、时间戳计时器（TSC），这是一个通过硬件寄存器实现的硬件计时器。TSC也是单调递增的，并且以固定的速率增长，也就是说它与频率无关。TSC的值可以使用编译器的内置函数__rdtsc查询。</p><p>CppPerformanceBenchmarks：<a href="https://gitlab.com/chriscox/CppPerformanceBenchmarks">https://gitlab.com/chriscox/CppPerformanceBenchmarks</a> 介绍了不同平台下使用不同API调用计时器的性能比较。</p><h4 id="微基准测试"><a href="#微基准测试" class="headerlink" title="微基准测试"></a>微基准测试</h4><p>为了验证某些假设，可以编写一个独立的微基准测试程序。通常，微基准测试程序是在优化某些特定功能时跟踪优化进展的手段。几乎所有现代编程语言都有基准测试框架，比如对C++来说可以使用Google Benchmark库，<a href="https://github.com/google/benchmark%E3%80%82">https://github.com/google/benchmark。</a></p><p>写基准测试程序时，重要的是确保测试场景在微基准测试程序运行时执行。优化编译器可能会消除使实验变得无用的代码（编译器优化掉）。防止编译器优化重要代码的一种常用手段是，使用类似 DoNotoptimize的辅助函数，这些辅助函数可以在幕后完成必要的内联汇编优化。</p><p>检验这件事的方式：审视一下基准测试的性能剖析文件，看看关注的代码是否凸显微热点。</p><p>性能数据分布之间的统计可以通过假设检验方法来识别和发现。一旦确定性能差异在统计上是显著的，那么性能加速比可以通过算术平均或几何平均来计算。</p><h3 id="CPU微架构"><a href="#CPU微架构" class="headerlink" title="CPU微架构"></a>CPU微架构</h3><h3 id="性能分析中的术语和指标"><a href="#性能分析中的术语和指标" class="headerlink" title="性能分析中的术语和指标"></a>性能分析中的术语和指标</h3><h3 id="性能分析方法"><a href="#性能分析方法" class="headerlink" title="性能分析方法"></a>性能分析方法</h3><h3 id="性能分析相关的CPU特性"><a href="#性能分析相关的CPU特性" class="headerlink" title="性能分析相关的CPU特性"></a>性能分析相关的CPU特性</h3><h2 id="基于源代码的CPU调优"><a href="#基于源代码的CPU调优" class="headerlink" title="基于源代码的CPU调优"></a>基于源代码的CPU调优</h2><h3 id="CPU前端优化"><a href="#CPU前端优化" class="headerlink" title="CPU前端优化"></a>CPU前端优化</h3><h3 id="CPU后端优化"><a href="#CPU后端优化" class="headerlink" title="CPU后端优化"></a>CPU后端优化</h3><h3 id="优化错误投机"><a href="#优化错误投机" class="headerlink" title="优化错误投机"></a>优化错误投机</h3><h3 id="其他调优"><a href="#其他调优" class="headerlink" title="其他调优"></a>其他调优</h3><h3 id="优化多线程应用程序"><a href="#优化多线程应用程序" class="headerlink" title="优化多线程应用程序"></a>优化多线程应用程序</h3>]]></content>
    
    
    <categories>
      
      <category>性能优化</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2024/05/03/hello-world/"/>
    <url>/2024/05/03/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    <categories>
      
      <category>DAG</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>测试文章</title>
    <link href="/2024/05/03/%E6%B5%8B%E8%AF%95%E6%96%87%E7%AB%A0/"/>
    <url>/2024/05/03/%E6%B5%8B%E8%AF%95%E6%96%87%E7%AB%A0/</url>
    
    <content type="html"><![CDATA[<h2 id="第一次测试"><a href="#第一次测试" class="headerlink" title="第一次测试"></a>第一次测试</h2><h2 id="第二次测试"><a href="#第二次测试" class="headerlink" title="第二次测试"></a>第二次测试</h2>]]></content>
    
    
    <categories>
      
      <category>C++20</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Hello C++</title>
    <link href="/2024/05/03/c++/c++/"/>
    <url>/2024/05/03/c++/c++/</url>
    
    <content type="html"><![CDATA[<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;hello world&quot;</span> &lt;&lt; std::endl;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="c-新特性"><a href="#c-新特性" class="headerlink" title="c++新特性"></a>c++新特性</h3><p>C++11 ~ C++23 主要新特性与示例：</p><h4 id="C-11"><a href="#C-11" class="headerlink" title="C++11"></a>C++11</h4><ul><li><strong>auto 关键字</strong><br>  自动类型推断。  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">auto</span> x = <span class="hljs-number">1</span>; <span class="hljs-comment">// x 推断为 int</span><br></code></pre></td></tr></table></figure></li><li><strong>范围for循环</strong>  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> v : &#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>&#125;) std::cout &lt;&lt; v &lt;&lt; std::endl;<br></code></pre></td></tr></table></figure></li><li><strong>lambda 表达式</strong>  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">auto</span> add = [](<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)&#123; <span class="hljs-keyword">return</span> a + b; &#125;;<br>std::cout &lt;&lt; <span class="hljs-built_in">add</span>(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>);<br></code></pre></td></tr></table></figure></li><li><strong>智能指针</strong>  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;memory&gt;</span></span><br>std::unique_ptr&lt;<span class="hljs-type">int</span>&gt; p = std::<span class="hljs-built_in">make_unique</span>&lt;<span class="hljs-type">int</span>&gt;(<span class="hljs-number">10</span>);<br></code></pre></td></tr></table></figure></li><li><strong>右值引用与移动语义</strong>  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">foo</span><span class="hljs-params">(std::string&amp;&amp; s)</span> </span>&#123; std::cout &lt;&lt; s; &#125;<br><span class="hljs-built_in">foo</span>(std::<span class="hljs-built_in">move</span>(std::<span class="hljs-built_in">string</span>(<span class="hljs-string">&quot;abc&quot;</span>)));<br></code></pre></td></tr></table></figure></li></ul><h4 id="C-14"><a href="#C-14" class="headerlink" title="C++14"></a>C++14</h4><ul><li><strong>泛型lambda</strong>  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">auto</span> f = [](<span class="hljs-keyword">auto</span> a, <span class="hljs-keyword">auto</span> b)&#123; <span class="hljs-keyword">return</span> a + b; &#125;;<br>std::cout &lt;&lt; <span class="hljs-built_in">f</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2.5</span>);<br></code></pre></td></tr></table></figure></li><li><strong>二进制字面量</strong>  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> n = <span class="hljs-number">0b1010</span>; <span class="hljs-comment">// 10</span><br></code></pre></td></tr></table></figure></li><li><strong>返回值类型自动推断</strong>  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">func</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-number">42</span>; &#125;<br></code></pre></td></tr></table></figure></li></ul><h4 id="C-17"><a href="#C-17" class="headerlink" title="C++17"></a>C++17</h4><ul><li><strong>结构化绑定</strong>  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++">std::tuple&lt;<span class="hljs-type">int</span>, <span class="hljs-type">double</span>&gt; t&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2.3</span>&#125;;<br><span class="hljs-keyword">auto</span> [a, b] = t;<br></code></pre></td></tr></table></figure></li><li><strong>if&#x2F;switch语句初始化</strong>  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">if</span> (<span class="hljs-type">int</span> x = <span class="hljs-number">5</span>; x &gt; <span class="hljs-number">3</span>) std::cout &lt;&lt; x;<br></code></pre></td></tr></table></figure></li><li><strong>内联变量</strong>  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> x = <span class="hljs-number">10</span>;<br></code></pre></td></tr></table></figure></li><li><strong>std::optional&#x2F;std::variant&#x2F;std::any</strong>  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;optional&gt;</span></span><br>std::optional&lt;<span class="hljs-type">int</span>&gt; o = <span class="hljs-number">5</span>;<br></code></pre></td></tr></table></figure></li></ul><h4 id="C-20"><a href="#C-20" class="headerlink" title="C++20"></a>C++20</h4><ul><li><strong>concepts 概念</strong>  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">concept</span> Addable = <span class="hljs-built_in">requires</span>(T a, T b) &#123; a + b; &#125;;<br></code></pre></td></tr></table></figure></li><li><strong>范围（ranges）库</strong>  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;ranges&gt;</span></span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i : std::views::<span class="hljs-built_in">iota</span>(<span class="hljs-number">1</span>, <span class="hljs-number">5</span>)) std::cout &lt;&lt; i;<br></code></pre></td></tr></table></figure></li><li><strong>协程（coroutine）</strong>  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;coroutine&gt;</span></span><br><span class="hljs-comment">// 简单协程示例略</span><br></code></pre></td></tr></table></figure></li><li><strong>三路比较符 &lt;&#x3D;&gt;（太空船操作符）</strong>  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">auto</span> res = <span class="hljs-number">1</span> &lt;=&gt; <span class="hljs-number">2</span>;<br></code></pre></td></tr></table></figure></li><li><strong>模块化（modules）</strong>  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// module; import; export 语法</span><br></code></pre></td></tr></table></figure></li></ul><h4 id="C-23"><a href="#C-23" class="headerlink" title="C++23"></a>C++23</h4><ul><li><strong>多维下标运算符</strong>  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Matrix</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-keyword">operator</span>[](<span class="hljs-type">size_t</span> i, <span class="hljs-type">size_t</span> j) <span class="hljs-type">const</span> &#123; <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; &#125;<br>&#125;;<br></code></pre></td></tr></table></figure></li><li><strong>std::expected</strong>  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;expected&gt;</span></span><br>std::expected&lt;<span class="hljs-type">int</span>, std::string&gt; e = <span class="hljs-number">42</span>;<br></code></pre></td></tr></table></figure></li><li><strong>范围for循环支持初始化</strong>  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; <span class="hljs-keyword">auto</span> v : &#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>&#125;) std::cout &lt;&lt; i++ &lt;&lt; v;<br></code></pre></td></tr></table></figure></li></ul><p>更多细节可参考官方文档。</p>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Hello GPU</title>
    <link href="/2024/05/03/GPU/GPU/"/>
    <url>/2024/05/03/GPU/GPU/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    <categories>
      
      <category>GPU</category>
      
    </categories>
    
    
  </entry>
  
  
  
  
</search>
